=begin
  Assumed - a R and Ruby installed/working 

Ruby Configuration
  
    gem install rserve-client
  
  On *nix systems folks often sudo to install.

  If for some reason you do not go the normal route of
  installing a gem (like you are using code
  downloaded from github at
  http://github.com/clbustos/Rserve-Ruby-client 
  ), make sure that your $LOAD_PATH
  has the library available when you run the program.
  You can even do this in line in the ruby program with

  $LOAD_PATH<<'C:\clbustos-Rserve-Ruby-client-v0.2.4-2-g47b0da7\clbustos-Rserve-Ruby-client-47b0da7\lib'  

R Configuration
  Uses ggplot2, R2HTML, RServe, and the iris data set.

  Install RServe as an R package

To run app
Start Rserve
  C:\Program Files\R\R-2.10.0\library\Rserve>Rserve

Should see output like this
  Rserve: Ok, ready to answer queries.

  
Start this application - specify a port
if you like

  iris_data_set_webapp.rb -p 4445

=end

=begin
This could be written out 
    require 'rubygems'
    require 'sinatra'
    ...

Instead all of the packages are included in an array 
(surrounded by brackets).  Then each is required as
we iterate through the array.
=end
['rubygems', 'sinatra', 'rserve','fileutils','haml'].each{|r|require r}

=begin
  So the packages being used are 
  
  rubygems (the ruby packaging system itself)
  sinatra (a minimal web app DSL)
  rserve (to integrate with R)
  fileutils (some convenience methods for file system access)
  haml - well, this one requires some explanation...

  HAML is one of the many Ruby mark up/templating 
  languages that seems to be in vogue today.  It seems
  to save a few keystrokes from writing straight HTML,
  but it slows me down since I think in HTML and end
  up working backwards to writing the HAML.  I kind of
  like the pythonesque interpretation of indentation
  being meaningful and that the HTML looks pretty.
  
  Anyway, it is used here but I am still on the fence 
  about it.
  
  More info at http://haml-lang.com/ 
  
  To experiment with haml using irb, just require haml, 
  create an engine and output the results to HTML.
  
  require 'haml'
  Haml::Engine.new('%h3 hello world').to_html
=end


=begin
  Create a global connection to Rserve.
=end
include Rserve
$c = Connection.new

=begin
   This kinda-sorta reloads sinatra which allows
   you to change code and view the changes without
   starting and stopping the server.  Only it does not
   always work - but it works enough for me that 
   I included it and just restart if things are not
   updating the way I expect.
=end
configure do
  Sinatra::Application.reset!
  use Rack::Reloader
end

=begin
  This looks at a line that comes from this file.
  Yep kind of wild.  If the line matches the regexp
  and is one of the get functions below (other than the)
  index itself, we pull out the url path and slap it in
  an HTML anchor.  This is a convenient way to have
  a home screen during development where each get URL
  can be invoked.
=end
def anchor(line)
  
  if line=~/get \'\/([a-z|A-Z])/
     l=line.split[1].gsub("'",'');  
     haml "%a{:href => '#{l}'}> #{l} \n%br"     
  end  
   
end

=begin
  Return a string of html with an heading that says 
  Links and a link to each get URL available in the
  web application (that appears in the current file).
  The list of links is generated by reading the contents
  of this file, and creating an anchor tag (if possible)
  using the anchor method above.
=end
get '/' do
  html=haml '%h3 Links'
  File.open(__FILE__).readlines.each{|l|html+=anchor(l).to_s}
  html
end

=begin
  This is a simple example of how integration with R works.
  The connection to RServe named $c is sent a string 
  of R code to evaluate.  We expect a single result
  that we interpret as a string.
=end

get '/r_version' do  
  $c.eval("R.version.string").as_string    
end


=begin
  This method creates an R script, evaluates it
  and returns a link to an image that will appear
  in the public directory that is in the same directory
  with this file.  The <<SCRIPT syntax is sometimes
  called a heredoc.  It is just a convenient way to 
  create multi line strings - you could use double
  quotes in this context as well.  The variables
  x, y and color that are passed in are substituted
  where you see #{x}, #{y}, #{color}
=end
def irisplot(x,y,color)
    script=<<SCRIPT
library(ggplot2)
  ggplot(
          data=iris, 
           aes(x=#{x}, y=#{y}, color=#{color})
         ) + geom_point()
   ggsave('#{FileUtils.pwd}/public/irisplot.png')
SCRIPT

  $c.eval(script)

  "<img src='irisplot.png' width='600', height='600'>"  
end

=begin
  This example demonstrates how to open an independent
  R script and run it.  See the iris.R script itself
  for more information about what is going on.  In general
  the R2HTML package is being used to create a file 
  whos handle is returned.  We then read the contents
  of the file in and these are returned as HTML.
=end
get '/iris_data' do  
  url=$c.eval(File.open('iris.R').readlines.join("\n")).as_string
  File.open(url).readlines()
end

=begin
You could read this data in using another computer
on the network
library(XML)
> u='http://nameofmachine:4445/iris'
> df=readHTMLTable(u)

=end

=begin
 Create an iris plot using the parameters passed in...
=end
post '/plot' do
  irisplot(params['x'],params['y'],params['color'])
end

=begin
 The form that provides input to create a plot of the iris data set.
=end
get '/iris_plot_input' do

  # Retrieve the iris data set column names into a ruby class variable.
  # These will be used to populate dropdowns.
  @colnames=$c.eval('data(iris);colnames(iris);').as_strings
  
  # WARNING Hard Coded Defaults below.  I used these so that 
  # we would have reasonable values by default.

  # Put all of the HAML markup in a string
html=<<HAML
%form{ :action => "/plot", :method => "post"}
  %table
    %tr
      %td
        %label{:for => "name"} x:
      %td  
        %select{:name=>'x'}  
          = @colnames.each do |col|
            %option{:value=> col, :selected => (col == 'Sepal.Length')} 
              =col
    %tr
      %td    
        %label{:for => "name"} y:    
      %td  
        %select{:name=>'y'}  
          = @colnames.each do |col|
            %option{:value=> col, :selected => (col == 'Sepal.Width')} 
              =col
    %tr
      %td    
        %label{:for => "name"} color:
      %td  
        %select{:name=>'color'}  
          = @colnames.each do |col|
            %option{:value=> col, :selected => (col == 'Species')} 
              =col
    %tr
      %td
        %input{:type => "submit", :value => "Create Plot"}
HAML

# Render it with the HAML engine
haml html

end